import Head from 'next/head'
import Image from 'next/image'
import { Inter } from 'next/font/google'
import styles from '@/styles/Home.module.css'
import { useRouter } from 'next/router'
import { ethers } from 'ethers'
import { useState } from 'react'
import { getChainName, getProviderForChainId } from '@/lib'
import { manifests } from '@/data/manifests'

const inter = Inter({ subsets: ['latin'] })



export default function Interact() {
    // Get id from URL
    const router = useRouter()
    const manifestName = router.query.manifestName as string
    const namespace = router.query.namespace as string
    const id = router.query.id as string

    if(!id) return <></>

    // @ts-ignore
    const manifest = manifests[manifestName]

    return (
        <Body manifest={manifest} namespace={namespace} id={id} />
    )

}


const Body = ({ manifest, id, namespace }: any) => {
    
    // Find target.
    let address
    if (namespace == 'system') {
        address = manifest.targets.system[id].address
    } else if (namespace == 'user') {
        const proxyName = `Proxy${id}`
        const proxy = manifest.targets.system[proxyName]
        address = proxy.address
        // address = manifest.targets.user[id].address
    }
    
    const impl = manifest.targets[namespace][id]
    const abi = impl.abi

    const chainId = manifest.deployments[0].chainId
    const networkName = getChainName(chainId)
    const provider = getProviderForChainId(chainId)
    let providerOrSigner: any = provider

    if(chainId == 31337) { // hardhat
        const signer = new ethers.Wallet('0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80', provider)
        providerOrSigner = signer
    }
    const contract = new ethers.Contract(address, abi, providerOrSigner)

    const [results, setResults] = useState({})

    const call = async (name: string, args: any) => {
        const tx = await contract[name](...args)
        const result = tx.hash ? tx.hash : tx
        setResults({ ...results, [name]: result })
    }

    return (
        <>
            <Head>
                <title>Interact</title>
                <meta name="description" content="Generated by create next app" />
                <meta name="viewport" content="width=device-width, initial-scale=1" />
                <link rel="icon" href="/favicon.ico" />
            </Head>
            <main className={styles.main}>
                <h3>Deployments / {networkName} / Contract</h3>
                <h1>Interact: {id}</h1>

                <pre>
                    {`Chain ID: ${manifest.deployments[0].chainId}
Address: ${address}
Target name (bytes32):
  ${ethers.encodeBytes32String(id)}`}
                </pre>
                <table>
                    <thead>
                        <tr>
                            <th>Function</th>
                            <th>Arguments</th>
                            <th>Call</th>
                            <th>Results</th>
                        </tr>
                    </thead>
                    <tbody>
                        {abi.map((item: any) => {
                            if (item.type == 'function') {
                                // detect if it's a write function
                                let isWrite = false
                                if (item.stateMutability == 'nonpayable' || item.stateMutability == 'payable') {
                                    isWrite = true
                                }

                                // detect if the function is payable.
                                let isPayable = false
                                if (item.stateMutability == 'payable') {
                                    isPayable = true
                                }

                                // button label.
                                let label = 'Read'
                                if (isWrite) {
                                    label = 'Write'
                                }

                                return (
                                    <tr key={item.name}>
                                        <td>
                                            {item.name}
                                        </td>
                                        <td>
                                            {item.inputs.map((input: any) => {
                                                // get input type
                                                let type = input.type

                                                return (
                                                    <div key={input.name}>
                                                        <label htmlFor={input.name}>{input.name}</label><br/>
                                                        <input type="text" placeholder={type} name={`${item.name}__${input.name}`} />
                                                    </div>
                                                )
                                            })}

                                            {/* payable input */}
                                            {isPayable && (
                                                <div>
                                                    <label htmlFor="payable">Payable</label><br/>
                                                    <input type="text" placeholder="eth" name={`${item.name}__payable`} />
                                                </div>
                                            )}
                                        </td>
                                        <td>
                                            <button onClick={
                                                () => {
                                                    const args = item.inputs.map((input: any) => {
                                                        const inputElement = document.querySelector(`input[name=${item.name}__${input.name}]`) as HTMLInputElement
                                                        return inputElement.value
                                                    })

                                                    // add payable
                                                    if (isPayable) {
                                                        const payableElement = document.querySelector(`input[name=${item.name}__payable]`) as HTMLInputElement
                                                        const payable = ethers.parseEther(payableElement.value)
                                                        args.push({ value: payable })
                                                    }

                                                    call(item.name, args)
                                                }
                                            }>
                                                {label}
                                            </button>
                                        </td>
                                        <td>
                                            <pre>
                                                {/* @ts-ignore */}
                                                {`${(results[item.name]) || ''}`}
                                            </pre>
                                        </td>
                                    </tr>
                                )
                            }
                        })}
                    </tbody>
                </table>
            </main>
        </>
    )
}